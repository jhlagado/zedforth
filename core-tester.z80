; T. (x -- )
; report the test number to a numeric output device
CODE "T.",2,tesDot
    ENTER 0
    call dot
    EXIT 0                      

; hasn ( x1 h0 -- h1 )
; compute h1 by hashing x1 and h0
CODE "hash",4,tesHash
    ENTER 0
    _swap
    _onePlus
    call xorr
    EXIT 0

; hash-n ( x1 x2 ... xn n -- h )
; hash n items from the stack and return the hash code
CODE "hash-n",6,tesHashN 
    ENTER 0
    _push 0
    call toR
tesHashN1:
    _dup
    _isZero
    jr z,tesHashN2
    _swap
    call rFrom
    call tesHash
    call toR
    _oneMinus
    jr tesHashN1
tesHashN2:
    _drop
    call rFrom
    EXIT 0                     

; Tstart ( -- )
; start testing
CODE "Tstart",6,tesStart 
    ENTER 0
    _push 0
    _store tesCount
    EXIT 0

; T{ ( -- )
; start a unit test
;  Tcount @ 1+ dup T. Tcount !
;  depth Tdepth !
CODE "T{",2,tesEnter 
    ENTER 0
    _fetch tesCount
    _onePlus
    _dup
    call tesDot
    _store tesCount
    call depth
    _store tesDepth
    EXIT 0

; }T ( y1 y2 ... yn -- hy )
; finish a unit test,
CODE "}T",2,tesExit 
    ENTER 0
    call depth
    _fetch tesDepth
    _minus
    call tesHashN
    call depth
    _store tesDepth
    EXIT 0

; == ( hy x1 x2 ... xn -- )
; compare actual output with expected output
CODE "==",2,tesEQ 
    ENTER 0
    call depth
    _fetch tesDepth
    _minus
    call tesHashN
    call EQ
    _isZero
    jr z,tesQ1
    _print "\r\nFailed! \r\n"
    halt
tesQ1:
    EXIT 0

; Tend ( -- )
; signal end of testing
CODE "Tend",4,tesEnd 
    ENTER 0
    _print "\r\nDone!\r\n"
    EXIT 0
