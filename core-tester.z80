; ; DE = TOS

; ; T. (x -- )
; ; report the test number to a numeric output device
; CODE "T.",tesDot
;     ENTER
;     jr z, tesDot1
;     _push $58
;     call emit
;     EXIT
; tesDot1:
;     _push $4F
;     call emit
;     EXIT                      

; ; hasn ( x1 h0 -- h1 )
; ; compute h1 by hashing x1 and h0
; CODE "hash",testHash
;     ENTER
;     _swap
;     _onePlus
;     call xorr
;     EXIT

; ; hash-n ( x1 x2 ... xn n -- h )
; ; hash n items from the stack and return the hash code
; CODE "hash-n",tesHashN 
;     ENTER
;     _push 0
;     _toR
; tesHashN1:
;     _dup
;     _isZero
;     jr z,tesHashN2
;     _swap
;     _rFrom
;     call tesHash
;     _toR
;     _oneMinus
;     jr tesHashN1
; tesHashN2:
;     _drop
;     _rFrom
;     EXIT                      

; ; Tstart ( -- )
; ; start testing
; CODE "Tstart",tesStart 
;     ENTER
;     _push 0
;     _store tesCount
;     EXIT

; ; T{ ( -- )
; ; start a unit test
; ;  Tcount @ 1+ dup T. Tcount !
; ;  depth Tdepth !
; CODE "T{",tesEnter 
;     ENTER
;     _fetch testCnt
;     _onePlus
;     _dup
;     call tesDot
;     _store tesCount
;     call depth
;     _store tesDepth
;     EXIT

; ; }T ( y1 y2 ... yn -- hy )
; ; finish a unit test,
; CODE "}T",tesExit 
;     ENTER
;     call depth
;     _fetch tesDepth
;     call minus
;     call tesHashN
;     call depth
;     _store tesDepth
;     EXIT

; ; == ( hy x1 x2 ... xn -- )
; ; compare actual output with expected output
; CODE "==",tesEQ 
;     ENTER
;     call depth
;     _fetch tesDepth
;     call minus
;     call tesHashN
;     call equal
;     _isZero
;     jr z,tesQ1
;     halt
; tesQ1:
;     EXIT

; ; Tend ( -- )
; ; signal end of testing
; CODE "Tend",tesEnd 
;     ENTER
;     _push -1
;     call tesDot
;     EXIT
