SER_EMPTYSIZE   equ 5
SER_FULLSIZE    equ 30H

IO_CTRL         equ $80
IO_DATA         equ $81
RTS_HIGH        equ $D6                ; 11010110
RTS_LOW         equ $96                ; 10010110

PORT_STATUS     equ $04
PORT_DATA       equ $03

serialInt:
    push AF
    push HL
    in A,(IO_CTRL)
    and $01
    jr z,serialInt1
    in A,(IO_DATA)
    call serialInt2
serialInt1:
    pop HL
    pop AF
    ei
    ret

; destroys: HL
serialInt2:
    push AF
    ld A,(serBufUsed)
    cp SER_BUFSIZE
    jr nz,serialInt21
    pop AF
    ret
serialInt21:
    ld HL,(serInPtr)
    inc HL
    ld A,L             ; Only need to check low byte becasuse lineBuf<256 bytes
    cp (serBuf + SER_BUFSIZE) & $FF
    jr nz,serialInt22
    ld HL,serBuf
serialInt22:
    ld (serInPtr),HL
    pop AF
    ld (HL),A
    ld A,(serBufUsed)
    inc A
    ld (serBufUsed),A
    cp SER_FULLSIZE
    jr c, serialInt23
    ld A,RTS_HIGH
    out (IO_CTRL),A
serialInt23:
    ret

; emit  ( c -- )
_code emit

; key   ( -- c )
; Wait for and return an input character.
CODE "key",3,key
    _enter
    _unjoin
key1:  
    _call qkey
    _zeroBranch key1 
    _rejoin
    _exit

; ?key  ( -- c T | F )
; Return input character and true, or a false if no input.
CODE "?key",4,qkey
    _enter
    _unjoin
    
    _serReady
    jr nz, qkey1
    _push FALSE
    jr qkey4
qkey1:
    ld DE,(serRdPtr)
    inc DE
    ld A,E                      
    cp (serBuf + SER_BUFSIZE) & $FF         ; Only need to check low byte
    jr nz,qkey2
    ld DE,serBuf
qkey2:
    di
    ld (serRdPtr),DE
    ld A,(serBufUsed)
    dec A
    ld (serBufUsed),A
    cp SER_EMPTYSIZE
    jr nc,qkey3
    ld A,RTS_LOW
    out (IO_CTRL),A
qkey3:
    ld A,(DE)
    _dup
    ld L,A
    ld H,0
    _push TRUE
    ei
qkey4:

    _rejoin
    _exit
