SER_EMPTYSIZE   equ 5
SER_FULLSIZE    equ 30H

IO_CTRL         equ $80
IO_DATA         equ $81
RTS_HIGH        equ $D6                ; 11010110
RTS_LOW         equ $96                ; 10010110

PORT_STATUS     equ $04
PORT_DATA       equ $03

.macro _initSerial
    ld HL,0
    ld (serbufused),HL

    ld HL,serbuf
    ld (serinptr),HL
    ld (serrdptr),HL

    ld A,RTS_LOW
    out (IO_CTRL),A

    im 1
    ei
.endm

serialInt:
    push AF
    push HL
    in A,(IO_CTRL)
    and $01
    jr z,serialInt1
    in A,(IO_DATA)
    call serialInt2
serialInt1:
    pop HL
    pop AF
    ei
    ret

; destroys: HL
serialInt2:
    push AF
    ld A,(serBufUsed)
    cp SER_BUFSIZE
    jr nz,serialInt21
    pop AF
    ret
serialInt21:
    ld HL,(serInPtr)
    inc HL
    ld A,L             ; Only need to check low byte becasuse lineBuf<256 bytes
    cp (serBuf + SER_BUFSIZE) & $FF
    jr nz,serialInt22
        ld HL,serBuf
serialInt22:
    ld (serInPtr),HL
    pop AF
    ld (HL),A
    ld A,(serBufUsed)
    inc A
    ld (serBufUsed),A
    cp SER_FULLSIZE
    jr c, serialInt23
    ld A,RTS_HIGH
    out (IO_CTRL),A
serialInt23:
    ret

; ; emit  ( c -- )
; CODE "emit",4,emit
;     ENTER 1
; emit1:
;     in A,(IO_CTRL)      ; Status byte
;     bit 1,A             ; Set Zero flag if still transmitting character
;     jr z,emit1
;     ld A,E
;     _drop
;     out (IO_DATA),A         ; Output the character
;     EXIT 1

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ; serReady - check if there is input waiting to be read
; ; flags: NZ if input ready
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; serReady:
;     ld A,(serBufUsed)
;     cp $0
;     ret

; ; key   ( -- c )
; ; Wait for and return an input character.
; CODE "key",3,key
;     ENTER 0
; key1:  
;     call qkey
;     _zeroBranch key1 
;     EXIT 0

; ; ?key  ( -- c T | F )
; ; Return input character and true, or a false if no input.
; CODE "?key",4,qkey
;     ENTER 1
;     .if TESTMODE
;         _fetch inptr                ; adr
;         _dup                        ; adr adr
;         _cat                        ; adr c
;         _swap                       ; c adr
;         _onePlus                    ; c adr+1
;         _store inptr                ; c
;         _push TRUE                  ; c true
;     .else
;         ld A,(serBufUsed)
;         cp $0
;         jr nz, qkey1
;         _push FALSE
;         jr qkey4
; qkey1:
;         ld HL,(serRdPtr)
;         inc HL
;         ld A,L             ; Only need to check low byte because lineBuf<256 bytes
;         cp (serBuf + SER_BUFSIZE) & $FF
;         jr nz,qkey2
;         ld HL,serBuf
; qkey2:
;         di
;         ld (serRdPtr),HL
;         ld A,(serBufUsed)
;         dec A
;         ld (serBufUsed),A
;         cp SER_EMPTYSIZE
;         jr nc,qkey3
;         ld A,RTS_LOW
;         out (IO_CTRL),A
; qkey3:
;         ld A,(HL)
;         _push TRUE
;         ei
; qkey4:
;     .endif
;     EXIT 1

